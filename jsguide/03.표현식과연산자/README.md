# 표현식과 연산자
- 표현식은 자바스크립트 인터프리터가 값으로 평가하는 자바스크립트 구문이다.

## 기본 표현식
- 가장 간단한 형태의 표현식은 '기본 표현식(primary expression)'으로 다른 표현식을 포함하지 않은 독립적 표현식이다.
  - 상수나 리터럴, 특정 키워드, 변수 참조가 기본 표현식이다.
```js
/***** 리터럴 *****/
1.23
'hello'
/pattern/

/***** 예약어 *****/
true
false
null
this // this 는 위치에 따라 값이 달라진다.

/***** 변수 참조 *****/
i
sum
// 만약, 해당 식별자를 이름으로 하는 변수가 없다면, 해당 표현식은 undefined 값으로 평가된다.
// ES5 의 엄격 모드에서는 ReferenceError 가 발생한다.
undefined // undefined 는 전역 변수로 null 처럼 키워드가 아니다.
```

### 객체와 배열의 초기화 표현식
- 객체와 배열 초기화 표현식은 말 그대로 새로 생성된 객체나 배열을 값으로 하는 표현식이다.
  - 객체 리터럴, 배열 리터럴이라고도 한다.
  - 이들은 일반 리터럴과 달리 기본 표현식이 아니다.
  - 이들은 프로퍼티와 원소 값을 지정하는 수많은 하위 표현식을 포함할 수 있기 때문이다.
- 배열 초기화 표현식은 대괄호 안에 쉼표로 구분된 표현식 리스트다.
  - 배열 초기화 표현식의 값은 새로 생성된 배열이다.
```js
[] // 빈 배열 : 대괄호 안에 표현식이 없으면 원소가 없음을 말한다.
[1 + 2, 3 + 4] // 두 개의 원소를 가진 배열 == [3, 7]
```
- 배열 초기화 표현식에 사용되는 원소 표현식으로 또 다른 배열 초기화 표현식이 올 수 있다. (중첩 배열)
```js
var matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
```
- 배열 리터럴에서 쉼표 사이의 값을 생략함으로써 원소의 값을 정의하지 않을 수도 있다.
  - 배열 초기화 표현식의 마지막 원소 표현식 다음에 쉼표가 올 수는 있지만, 맨 마지막의 원소는 만들어지지 않는다.
```js
var sparseArray = [1, , , , 5]; // [1, undefined x 3, 5]
var sparseArray2 = [1, , , , ,]; // [1, undefined x 4] : [1, undefined x 5] 가 아니다.
```
- 객체 초기화 표현식은 중괄호가 사용되고, 각 하위 표현식 앞에는 프로퍼티 이름과 콜론(:) 이 붙는다.
```js
var p = { x: 2.3, y: -1.2 };
var q = { };
q.x = 2.3; q.y = -1.2;
q['z'] = 5;
```
- 객체 리터럴도 중첩될 수 있다.
```js
var rectangle = {
  upperLeft: { x: 2, y: 2 },
  lowerRight: { x: 4, y: 5}
};
```

## 함수 정의 표현식
- 함수 정의 표현식은 함수를 정의하고, 함수 정의 표현식의 값은 새로 정의된 함수다.
- 다시 말해, 함수 정의 표현식은 '함수 리터럴'이라고 할 수 있다.
- 함수 정의 표현식은 일반적으로 function 키워드와 괄호로 둘러쌓인 쉼표로 구분된 식별자(매개 변수 이름)들, 중괄호로 둘러쌓인 코드 (함수 몸체)로 이루어진다.
```js
var square = function (x) { return x * x; }
```
- 함수 정의 표현식은 함수 이름을 포함할 수 있다.


## 프로퍼티 접근 표현식
- 프로퍼티 접근 표현식은 객체의 프로퍼티나 배열의 원소 값으로 평가되며, 두 가지 문법으로 프로퍼티에 접근할 수 있다.
```js
표현식.식별자
// 표현식은 객체이고, 식별자는 찾고자 하는 프로퍼티 이름이다.

표현식[표현식]
// 대괄호 안의 표현식은 찾고자하는 객체 프로퍼티의 이름이 될 수도 있고,
// 배열 내 원소 인덱스 값이 될 수도 있다.

var o = { x: 1, y: { z: 3 } };
var a = [o, 4, [5, 6]];

o.x; // 1 : 객체 o 의 프로퍼티 x
o.y.z; // 3 : 객체 o.y 의 프로퍼티 z
o['x']; // 1 : 객체 o 의 프로퍼티 x
a[1]; // 4 : 배열 a 의 인덱스 1 위치에 있는 원소
a[2]['1']; // 6 : 배열 a[2] 의 인덱스 1 위치에 있는 원소
a[0].x; // 1 : 배열 a 의 인덱스 0 위치에 있는 객체 o 의 프로퍼티
```
- 위에서 먼저 나오는 표현식이 null 이나 undefined 라면 이들 값은 프로퍼티를 갖지 않으며, 프로퍼티나 원소를 찾을 때, TypeError 에러가 발생한다.
- 객체 표현식 다음에 (.) 과 식별자가 올 경우, 식별자를 이름으로 갖는 프로퍼티의 값을 찾게 되고, 해당 프로퍼티가 존재하지 않으면, 해당 표현식의 값은 undefined 가 된다.
- 만약, 먼저 나오는 표현식이 객체 혹은 배열이 아니라면, 객체로 변환된다.
- (.) 을 이용한 표현식을 사용할 때, 프로퍼티 이름으로 오지 못하는 경우가 있다.
  - 프로퍼티 이름이 예약어인 경우
  - 구두점 문자나 공백을 포함하는 경우
  - 숫자일 경우
  - 위 세 가지 경우에는 반드시 [] 를 이용한 표현식을 사용해야 한다.
- [] 표현식에서 8 진수나 16 진수를 사용할 경우, 조심해야 한다.
```js
var arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
arr[8]; // 8
arr['8']; // 8
arr[010]; // 8
arr['010']; // undefined
```

## 호출 표현식
- 호출 표현식 (invocation expression) 은 자바스크립트에서 함수나 메소드를 호출하는 문법이다.
  - 호출될 함수를 가리키는 함수 표현식으로 시작한다. 그 뒤에는 괄호 안에 쉼표로 구분된 여러 개의 인자들이 온다.
```js
f(0); // f 는 함수 표현식이고, 0 은 인자 표현식이다.
Math.max(x, y, z); // Math.max 는 함수고, x, y, z 는 인자다.
a.sort(); // a.sort 는 함수고, 인자가 없다.
```
- 함수 표현식의 값이 호출할 수 있는 객체가 아닐 경우 TypeError 에러가 발생한다.
- 값을 반환하기 위해 return 문을 사용하면, 그 값이 호출 표현식이 값이 되며, 함수가 값을 반환하지 않는다면, 함수 표현식의 값은 undefined 가 된다.
- 모든 호출 표현식은 한 쌍의 괄호와 괄호 앞에 오는 표현식으로 이루어 지는데, 만약, 그 표현식이 프로퍼티 접근 표현식이면, 호출 표현식은 메소드 호출이 된다.
  - 메소드가 호출되면, 함수 몸체 내에서의 this 는 프로퍼티 접근 표현식이 가리키는 객체나 배열이 된다.
  - 이를 통해, 객체 지향적으로 프로그램을 작성할 수 있다.
  - 메소드 호출이 아닌 호출 표현식에서 this 는 보통 전역 객체이다.
  - ES5 엄격 모드에서는, this 는 undefined 가 된다.

## 객체 생성 표현식
- 객체 생성 표현식 (object creation expression) 은 새 객체를 생성하고, 생성자라고 부르는 함수를 호출해 객체에 속한 프로퍼티들을 초기화한다.
- 객체 생성 표현식은 new 키워드가 앞에 붙는다.
```js
new Object();
new Point(2, 3);

// 객체의 생성자 함수를 인자 없이 호출할 때, 괄호를 생략할 수 있다.
new Object;
new Date;
```
- 객체 생성 표현식이 평가될 때, 자바스크립트 인터프리터는 먼저 새로운 빈 객체를 생성하는데, 이때 생성된 객체는 {} 에 의해 생성되는 객체와 동일하다.
- 다음으로, 주어진 인자들과 함께 생성자를 호출하는데, 이때 방금 생성된 새 객체를 this 키워드의 값으로 설정하여 전달한다.
- 생성자 함수는 이 this 키워드를 통해 새로 생성된 객체의 프로퍼티들을 초기화한다.
  - 일반적으로 생성자로 사용되는 함수는 값을 반환하지 않는다.
- 객체 생성 표현식의 값은 새롭게 생성되고 초기화된 객체이다.
- 생성자가 특정 객체 값을 반환할 경우, 이 값이 객체 생성 표현식의 값이 되고, 생성자를 통해 새로 생성된 객체는 버려진다.

## 연산자 개요
- 연산자는 수식 표현식, 비교 표현식, 논리 표현식, 할당 표현식 등에서 다양하게 사용된다.
- 연산자는 보통 +, -, = 와 같은 부호로 표현되지만, delete, instanceof, typeof 등처럼 키워드로 표현되기도 한다.
- 다음 표는 연산자를 연산 우선순위로 정렬한 것으로 위에 있는 연산자의 우선순위가 더 높다.
  - 빈 칸으로 우선순위 단계를 구분한다.
  - 결합 방향은 연산자 결합 방향이며,
    - L : 왼쪽에서 오른쪽으로
    - R : 오른쪽에서 왼쪽으로 를 뜻한다.
  - 피연산자 개수는 해당 연산자가 갖는 피연산자의 개수이다.
  - 피연산자 타입은 연산자가 사용할 피연사자들의 타입이다.
  - 반환 열은 연산자 연산 후, 반환되는 타입이다.
<table><thead>
<tr><th>연산자</th><th>수행되는 연산</th><th>결합 방향</th><th>피연산자 개수 및 타입</th><th>반환</th></tr>
</thead><tbody>
<tr><td>++</td><td>전치 또는 후치 증가</td><td>R</td><td>1 | 숫자</td><td>숫자</td></tr>
<tr><td>--</td><td>전치 또는 후치 감소</td><td>R</td><td>1 | 숫자</td><td>숫자</td></tr>
<tr><td>-</td><td>단항 마이너스</td><td>R</td><td>1 | 숫자</td><td>숫자</td></tr>
<tr><td>+</td><td>숫자로 변환</td><td>R</td><td>1 | 숫자</td><td>숫자</td></tr>
<tr><td>~</td><td>비트 단위 NOT</td><td>R</td><td>1 | 정수</td><td>정수</td></tr>
<tr><td>!</td><td>논리 NOT</td><td>R</td><td>1 | 불린</td><td>불린</td></tr>
<tr><td>delete</td><td>프로퍼티 제거</td><td>R</td><td>1 | Whatever</td><td>불린</td></tr>
<tr><td>typeof</td><td>피연산자 타입 반환</td><td>R</td><td>1 | Whatever</td><td>문자열</td></tr>
<tr><td>void</td><td>undefined 반환</td><td>R</td><td>1 | Whatever</td><td>undefined</td></tr>
<tr><td colspan="5"></td></tr>
<tr><td>&#42;, /, %</td><td>곱셈, 나눗셈, 나머지</td><td>L</td><td>2 | 숫자, 숫자</td><td>숫자</td></tr> 
<tr><td colspan="5"></td></tr>
<tr><td>+, -</td><td>덧셈, 뺄셈</td><td>L</td><td>2 | 숫자, 숫자</td><td>숫자</td></tr>
<tr><td>+</td><td>문자열 더하기 </td><td>L</td><td>2 | 문자열, 문자열</td><td>문자열</td></tr>
<tr><td><<</td><td>왼쪽 쉬프트</td><td>L</td><td>2 | 숫자, 숫자</td><td>숫자</td></tr>
<tr><td>>></td><td>오른쪽 쉬프트(부호 비트 확장)</td><td>L</td><td>2 | 숫자, 숫자</td><td>숫자</td></tr>
<tr><td>>>></td><td>오른쪽 쉬프트(부호 비트 확장 X)</td><td>L</td><td>2 | 숫자, 숫자</td><td>숫자</td></tr>
<tr><td colspan="5"></td></tr>
<tr><td><, <=, >, >=</td><td>숫자 비교</td><td>L</td><td>2 | 숫자, 숫자</td><td>불린</td></tr>
<tr><td><, <=, >, >=</td><td>문자열 비교</td><td>L</td><td>2 | 문자열, 문자열</td><td>불린</td></tr>
<tr><td>instanceof</td><td>객체 타입 확인</td><td>L</td><td>2 | 객체, 생성자</td><td>불린</td></tr>
<tr><td>in</td><td>프로퍼티 존재 여부 확인</td><td>L</td><td>2 | 문자열, 객체</td><td>불린</td></tr>
<tr><td colspan="5"></td></tr>
<tr><td>==</td><td>동등한지 비교</td><td>L</td><td>2 | Whatever</td><td>불린</td></tr>
<tr><td>!=</td><td>동등하지 않은지 비교</td><td>L</td><td>2 | Whatever</td><td>불린</td></tr>
<tr><td>===</td><td>일치하는지 비교</td><td>L</td><td>2 | Whatever</td><td>불린</td></tr>
<tr><td>!==</td><td>일치하지 않는지 비교</td><td>L</td><td>2 | Whatever</td><td>불린</td></tr>
<tr><td colspan="5"></td></tr>
<tr><td>&</td><td>비트 단위 AND</td><td>L</td><td>2 | 숫자</td><td>숫자</td></tr>
<tr><td colspan="5"></td></tr>
<tr><td>^</td><td>비트 단위 XOR</td><td>L</td><td>2 | 숫자</td><td>숫자</td></tr>
<tr><td colspan="5"></td></tr>
<tr><td>|</td><td>비트 단위 OR</td><td>L</td><td>2 | 숫자</td><td>숫자</td></tr>
<tr><td colspan="5"></td></tr>
<tr><td>&&</td><td>논리 AND</td><td>L</td><td>2 | Whatever</td><td>우변의 타입</td></tr>
<tr><td colspan="5"></td></tr>
<tr><td>||</td><td>논리 OR</td><td>L</td><td>2 | Whatever</td><td>좌변의 타입 혹은 우변의 타입</td></tr>
<tr><td colspan="5"></td></tr>
<tr><td>? :</td><td>조건부 연산자</td><td>R</td><td>3 | 불린, Whatever, Whatever</td><td>: 좌우 중 하나</td></tr>
<tr><td colspan="5"></td></tr>
<tr><td>=</td><td>할당</td><td>R</td><td>2 | 좌변 값, Whatever</td><td>우변의 타입</td></tr>
<tr><td>&#42;=, /=, %=, +=, -=, &=, ^=, |=, <<=, >>=, >>>=</td><td>연산을 수반하는 할당</td><td>R</td><td>2 | 좌변 값, Whatever</td><td>우변의 타입</td></tr>
<tr><td colspan="5"></td></tr>
<tr><td>,</td><td>첫 번째 피연산자를 무시하고, 두 번째 피연산자 반환</td><td>L</td><td>2 | Whatever</td><td>두 번째 피연산자 타입</td></tr>
</tbody></table>

### 피연산자 개수
- 연산자에 필요한 피연산자 개수에 따라 연산자들을 분류할 수 있다.
- 대부분 연산자는 2 항 연산자이다.
- 2 항 연산자는 두 개의 표현식을 조합하여, 하나의 복합 표현식을 만든다.
- 단항 연산자는 하나의 표현식을 좀 더 복잡한 단일 표현식으로 만든다.
- 삼항 연산자는 조건부 연산자로, 세 표현식들의 값을 조합해 하나의 표현식으로 만든다.

### 피연산자와 반환 타입
- 일부 연산자는 값의 타입과 무관하게 동작하지만, 대부분은 피연산자 타입이 정해져 있다.
- 연산자들은 대체로 특정 타입의 값을 반환한다.
- 자바스크립트는 필요할 때마다 피연산자의 타입을 변환한다.
  - '3' * '5' 는 3 * 5 로 변환되어 연산을 수행한다.
- 일부 연산자는 피연산자 타입에 따라 다르게 작동한다.
  - + 연산자는 숫자끼리 연산할 때, 숫자의 덧셈을 하고,
  - 문자열끼리 연산할 때, 문자열 concatenate 를 한다.

### 좌변 값
- 좌변 값이란 할당 표현식의 좌변에 나타날 수 있는 표현식이다.
- 변수, 객체 프로퍼티, 배열 원소가 좌변 값으로 올 수 있다.
- ECMAScript 명세에 의하면 내장 함수도 좌변 값을 반환할 수 있다고 한다.
  - 하지만, 실제로 이와 같은 형태로 정의된 내장 함수는 하나도 없다.

### 연산자 부수 효과 (Side effect)
- 2 * 3 과 같은 간단한 표현식의 평가 결과는 프로그램 상태에 영향을 주지 않는다.
- 하지만, 일부 표현식은 사이드 이펙트를 가진다. (할당 연산자가 대표적인 경우다.)
  - 변수나 객체의 프로퍼티에 값을 할당하면, 그 변수나 프로퍼티를 사용하는 모든 표현식의 값이 바뀐다.
  - ++와 --도 실행되면 기존의 값을 변경하는 묵시적 할당이 이루어진다.
  - delete 연산자는 해당 변수 혹은 객체의 프로퍼티에 undefined 값을 할당하는 것과 유사하다. (똑같지는 않다.)

### 연산자 우선순위
- 연산자는 위의 표와 같은 우선순위를 가지며, 우선순위를 변경하기 위해서는 명시적으로 괄호를 사용한다.
```js
w = 3 + 5 * 2; // 13
w = (3 + 5) * 2; // 16
```
- 프로퍼티 접근이나 호출 표현식은 위 표에 나열된 연산자들보다 우선순위가 높다.
```js
typeof my.functions[x](y)
// 프로퍼티 접근과 함수 호출이 끝난 뒤에 typeof 를 수행한다.
```

### 연산자 결합 방향
- 결합 방향이 L 인 경우 표현식이 다음과 같다.
```js
w = x - y -z;
w = ((x - y) - z);
```
- 결합 방향이 R 인 경우 표현식이 다음과 같다.
```js
x = ~-y;
w = x = y = z;
q = a ? b : c ? d : e ? f : g;

x = ~(-y);
w = (x = (y = z));
q = a ? b : (c ? d : (e ? f : g));
```

### 평가 순서
- 연산자 우선순위와 결합 방향은 복잡한 표현식에서 어떤 연산이 우선적으로 수행되는지를 (order of evaluation) 결정한다.
- 하지만, 어떤 부-표현식 (sub-expression) 이 먼저 평가되는지를 정하지는 않는다.
  - 예를 들어, w = x + y * z; 의 경우,
    - 부-표현식 w 가 먼저 평가되고, x, y, z 가 차례대로 평가된다.
    - 그리고, y 와 z 를 곱한 후, x 값을 더해서 표현식 w 가 가리키는 변수나 객체 프로퍼티로 값을 할당한다.
- 평가 순서는 표현식 중 다른 표현식의 값에 영향을 주는 표현식이 포함된 경우에만 중요하다.
  - 만약, 표현식 x 가 z 에서 사용하고 있는 임의의 변수 값을 증가시킨다고 할 때, x 가 반드시 z 보다 먼저 평가되어야 한다.

## 산술 표현식
- 기본 산술 연산자는 &#42;, /, %, +, - 이다.
- 이들은 피연산자를 평가하고, 값을 숫자로 변환한다. 그 다음 피연사자들의 최종 값으로 연산을 수행한다.
  - 수로 변환이 불가능한 피연산자는 NaN 값으로 변환되며, 피 연산자 중 하나라도 NaN 일 경우 연산 결과도 NaN 이다.
- / 연산자는 첫 번째 피연산자를 두 번째 피연산자로 나눈다.
  - 모든 숫자는 부동소수점 숫자로 취급되며, 나눗셈 연산의 결과도 부동소수점 숫자이다.
  - 값을 0 으로 나누면, Infinity 또는 -Infinity 가 된다.
    - 단, 0 / 0 은 NaN 이다.
- % 연산자는 첫 번째에 대한 두 번째 피연산자의 나머지 연산을 수행한다.
  - 결과의 부호는 첫 번째 피연산자의 부호와 동일하다.
```js
5 % 2; // 1
-5 % 2; // -1
```
  - 일반적으로 나머지 연산자는 정수 타입의 피연산자에 대해 사용되지만, 부동 소수점 값에 대해서도 적용할 수 있다.
```js
6.5 % 2.1; // 0.2
```

### 덧셈 연산자 +
- + 연산자가 이항 연산자로 사용될 때, 피연산자 숫자 값을 더하거나, 피연산자 문자열을 이어 붙인다.
```js
1 + 2; // 3
'hello' + ' ' + 'world'; // hello world
'1' + '2' // '12'
```
- 두 피연산자가 모두 숫자거나 문자열일 경우, + 연산자의 일은 명확하다.
- 하지만, 이 외의 경우에는 타입 변환이 이루어져야 하고, 연산은 타입 변환이 이루어진 후 수행된다.
- + 연산자는 타입 변환 시 문자열 이어붙이기를 먼저 수행한다.
  - 만일 피연산자 중 하나가 문자열이거나 문자열로 바꿀 수 있는 객체라면 다른 피연산자를 문자열로 변환한 후 두 문자열을 이어붙인다.
  - 숫자의 덧셈은 두 피연산자 값이 모두 문자열이 아니거나, 문자열로 변환할 수 없을 때만 수행한다.
```js
1 + 2; // 3
'1' + '2'; // 12
'1' + 2; '12'
1 + { }; '1[object Object]'
true + true; // 2 : 1 + 1
2 + null; // 2 : 2 + 0
2 + undefiend; // NaN : 2 + NaN
```
- 여러 문자열과 여러 숫자를 사용할 때는 연산자 결합 법칙이 적용되지 않는다. (연산자 실행 순서에 따라 연산 결과가 달라진다.)
```js
1 + 2 + ' blind mice'; // '3 blind mice'
1 + (2 + ' blind mice'); // '12 blind mice'
```

### 단항 산술 연산자
- 단항 연산자는 하나의 피연산자 값을 수정해서 새 값을 만든다.
__단항 덧셈(+)__
- 단항 덧셈 연산자는 피연산자를 숫자(또는 NaN)로 바꾼 후 값을 반환한다.
- 피연산자가 숫자일 경우 아무 일도 하지 않는다.
```js
var ts = +new Data(); // 1469721829959
var s = +'3'; // 3
var i = 5; // 5
```
__단항 뺄셈(-)__
- 단항 뺄셈 연산자는 피연산자를 숫자로 변환을 시도하고, 성공하면 결과 값의 부호를 바꾼다.
```js
var mts = -new Date(); // 1469721962836
var ms = -'3'; // -3
var mnu = -null; // -0
var mud = -undefined; // NaN
var mi = -5; // -5
```

__증가(++)__
- ++ 연산자는 단항 피연산자에 대해 증가 연산을 한다.
- 증가 연산자가 피연산자의
  - 왼쪽에 위치할 경우, 전치증가(pre-incremenet) 연산자라고 하며,
    - 전치증가를 하면, 피연산자를 증가시킨 뒤, 증가된 값을 반환한다.
  - 오른쪽에 위치할 경우, 후치증가(post-increment) 연산자라고 한다.
    - 후치증가를 하면, 피연산자를 증가시킨 뒤, 증가되지 않은 원래의 값을 반환한다.
```js
var i;
i = 1, j == ++1; // i = 2, j = 2
i = 1, j = 1++; // i = 2, j = 1
```
- 자바스크립트는 자동으로 세미콜론을 삽입해주기 때문에, 후치증가 연산자와 그 앞에 있는 피연산자 사이에서 줄바꿈을 하면 안된다.

__감소(--)__
- -- 연산자는 단항 피연산자에 대해 감소 연산을 한다.
- 나머지 특징은 ++ 연산자와 같다.

### 비트 단위 연산자
- 비트 단위 연산자들은 2진수를 저수준에서 조작하는 데 사용한다.
- &, |, ^, ~ 는 피연산자의 개별 비트에 대해 불린 대수(Boolean Algebra) 를 수행한다.
  - 이때, 피연산자의 개별 비트는 불린 값으로 취급된다. (1 = true, 0 = false)
- <<, >>, >>> 연산자는 왼쪽이나 오른쪽으로 비트를 이동할 때 사용된다.
- 비트 단위 연산자의 피연산자로는 정수가 오며, 64 비트 부동 소수점 표현법이 아니라, 32 비트 정수 표현법을 따른다.
- 비트 단위 연산자는 피연산자의 값을 숫자로 바꾸고, 32 번째 이후 비트를 잘라내 강제로 피연산자 값을 32 비트로 만든다.
- 쉬프트 연산자의 우측 피연산자는 0 과 31 사이의 값이어야 한다.
  - 쉬프트 연산자는 피연산자를 32 비트 정수로 변환한 후, 6 번째 이상의 비트를 버림으로써, 이 숫자가 적절한 범위에 들도록 한다.
- NaN, Infinity, -Infinity 는 비트 단위 연산자의 피연산자로 사용될 때, 모두 값이 0 으로 바뀐다.
  - 0 ~ 31 사이의 값이 아닌 값들도 마찬가지이다.

__비트 단위 AND(&)__
- & 연산자는 두 정수 피연산자의 개별 비트끼리 Boolean AND 연산을 수행한다.
- 동일 위치의 비트가 두 연산자에서 모두 설정되어 있어야만 결과 값의 해당 비트도 설정된다.
```js
0x1234 & 0x00FF; // 0x0034
/*
 * 0001 0010 0011 0100
 * 0000 0000 1111 1111
 *---------------------
 * 0000 0000 0011 0100 | 0x0034
 */
```

__비트 단위 OR(|)__
- | 연산자는 두 정수 피연산자의 개별 비트끼리 Boolean OR 연산을 수행한다.
- 적어도 하나 이상의 피연산자에서 특정 위치의 비트가 설정되어 있으면, 결과 값의 해당 위치 비트가 설정된다.
```js
0x1234 | 0x00FF; // 0x12FF
/*
 * 0001 0010 0011 0100
 * 0000 0000 1111 1111
 *---------------------
 * 0001 0010 1111 1111 | 0x12FF
 */
```

__비트 단위 XOR(^)__
- ^ 연산자는 두 정수 피연산자의 개별 비트끼리 Exclusive Boolean OR (XOR) 연산을 수행한다.
- 두 연산자의 비트 중 하나만 true 일 경우에만 결과 값의 해당 위치 비트를 설정한다.
```js
0x1234 ^ 0x00FF; // 0x12CB
/*
 * 0001 0010 0011 0100
 * 0000 0000 1111 1111
 *---------------------
 * 0001 0010 1100 1011 | 0x12CB
 */
```

__비트 단위 NOT(~)__
- ~ 연산자는 단항 연산자로 하나의 정수 피연산자 앞에 위치하며, 피연산자의 모든 비트를 반전시킨다.
- 자바스크립트에서 부호 있는 정수를 표현하는 방법으로 인해, 어떤 값에 ~ 연산자를 적용하면, 그 값의 부호를 바꾸고 1 을 빼는 것과 같은 결과를 얻는다.
```js
~0x0F; // 0xFFFFFFF0 : -16 과 같다.
/*
 * 0000 0000 0000 1111
 *---------------------
 * 1111 1111 1111 0000 | 0xFFF0
 */
```

__왼쪽으로 이동(<<)__
- << 연산자는 첫 번째 피연산자의 모든 비트를 두 번째 피연산자만큼 왼쪽으로 이동시킨다.
- 두 번째 피연산자는 반드시 0 과 31 사이의 정수여야 한다.
- 이동으로 인해 새로 메꾸어질 수는 0 이며, 기존 32 번째 비트는 사라진다.
```js
7 << 2; // 28
/*
 * 0000 0000 ... 0000 0111
 *-------------------------
 * 0000 0000 ... 0001 1100 | 0x1C
 */
```

__오른쪽으로 이동(>>)__
- >> 연산자는 첫 번째 피연산자의 모든 비트를 두 번째 피연산자만큼 오른쪽으로 이동시킨다.
- 두 번째 피연산자는 반드시 0 ~ 31 사이의 정수여야 한다.
- 비트를 오른쪽으로 이동시키면 오른쪽 비트들은 손실되며, 왼쪽 자리에 채워지는 비트는 첫 번째 피연산자의 부호 비트가 된다.
  - 첫 번째 피연산자 비트가 양수이면 최상위 비트는 0 이 되고, 음수면 1 이 된다.
```js
7 >> 1; // 3
/*
 * 0000 0000 ... 0000 0111
 *-------------------------
 * 0000 0000 ... 0000 0011 | 0x3
 */

-7 >> 1; // -4
/*
 * 0000 0000 ... 1111 1001
 *-------------------------
 * 0000 0000 ... 1111 1100 | -4
 */
```

__0 을 채우면서 오른쪽으로 이동(>>)__
- 왼쪽 자리에 새로 들어오는 비트가 첫 번째 피연산자의 부호와 상관 없이 0 이다.
```js
-1 >> 4; -1
/*
 * 1111 1111 ... 1111 1111
 *-------------------------
 * 1111 1111 ... 1111 1111 | -1
 */

-1 >>> 4; 268435455
/*
 * 1111 1111 ... 1111 1111
 *-------------------------
 * 0000 1111 ... 1111 1111 | 0xfffffff
 */
```

## 관계형 표현식
- 관계형 연산자는 두 피연산자 값의 관계를 검사하여 관계가 성립하면 true, 그렇지 않으면 false 를 반환한다.
- 주로 if, while, for 에서 사용된다.

### 동치돠 부등치 연산자
- == 와 === 모두 주어진 값이 같은지 확인하는 데 쓰이지만, 기준은 서로 다르다.
  - == 는 동치 연산자로, 피연산자 타입을 가지리 않고, 주어진 피연산자 값이 같은지(두 피연산자가 동등한지)만 판단한다.
  - === 는 두 피연산자가 일치하는지 확인한다.
- != 와 !== 연산자는 == 와 === 연산자가 비교하는 것과 반대이다.
  - != 는 두 값이 서로 동치일 경우에만 false 를 반환한다.
  - !== 는 두 값이 서로 일치할 경우에만 false 를 반환한다.
- 자바스크립트는 값 비교가 아닌 참조 비교를 수행한다.
  - 객체는 자기 자신과는 같지만 다른 객체와는 같지 않다.
  - 예를 들어, 두 개의 서로 다른 객체가 같은 수의 프로퍼티를 갖고, 각 프로퍼티 이름과 값이 서로 같아도 두 객체는 다른 객체이다.
  - 마찬가지로 두 배열이 같은 원소들을 같은 순서대로 가지고 있어도, 이 두 배열은 같지 않다.
  - === 연산자는 두 값이 일치하는지 여부를 판단할 때, 다음 규칙을 따르며 타입 변환은 하지 않는다.
    - 두 값의 타입이 서로 다르면 두 값은 일치하지 않는다.
    - 두 값이 모두 null 이거나 모두 undefined 면, 두 값은 일치한다.
    - 두 값이 모두 불린 true 거나 모두 false 일 경우, 두 값은 일치한다.
    - 적어도 하나의 값이 NaN 이면 두 값은 일치하지 않는다. NaN 은 자기 자신을 포함하여 어떤 값과도 일치아지 않는다. (임의의 값 x 가 NaN 인지 검사하기 위해서는 x !== x 와 같이 사용하면 된다.)
    - 두 값이 모두 숫자고 같은 값을 가지면, 두 값은 일치한다. (0 과 -0 두 값도 일치한다.)
    - 두 값이 모두 문자열이고, 같은 위치에 같은 16 비트 값을 가지면, 두 값은 일치한다. (자바스크립트는 유니코드 문자열에 대해 정규화 과정을 수행하지 않는다. 육안상 같은 문자더라도 다르게 인코딩 되어 있을 수 있기 때문에, String.localeCompare() 를 참고해야 할 때도 있다.)
    - 두 값이 모두 같은 객체나 배열 또는 함수를 참조하면, 두 값은 일치한다. 두 값이 서로 다른 객체를 참조할 경우, 두 프로퍼티가 일치해도 두 값은 일치하지 않는다.
  - 동치 연산자 == 는 같은 타입이 아닐 경우, 일부 피연산자에 대해 타입 변환을 시도한 뒤, 다시 비교를 하며, 다음 규칙을 따른다.
    - 두 값의 타입이 같은 경우, 두 값이 일치하는지 테스트하며, 두 값이 일치하면 동치, 일치하지 않으면 동치가 아니다.
    - null 과 undefined 는 동등하다.
    - 한 값이 숫자고, 다른 하나가 문자열이면, 문자열을 숫자로 변환하고, 비교를 한다.
    - 두 값 중 하나가 true 이면 이를 1 로 변환하며, false 이면 0 으로 변환하고 비교한다.
    - 한 값이 객체고 다른 값은 숫자 또는 문자이면, 객체를 원시 타입의 값으로 변환한 뒤 비교한다.
    - 앞에서 열거하지 않은 기타 값들의 조합은 동치가 아니다.
```js
'1' == true
// 먼저, true 가 1 이 되며, '1' 이 1이 되어 true 를 반환한다.
```

### 비교 연산자
- 비교 연산자는 두 피연산자 값의 상대적인 순서를 판단한다.
__더 작다(<)__
- 첫 번째 피연산자가 두 번째 피연산자보다 작으면 true, 아니면 false

__더 크다(<)__
- 첫 번째 피연산자가 두 번째 피연산자보다 크면 true, 아니면 false

__작거나 같다(>=)__
- 첫 번째 피연산자가 두 번째 피연산자보다 작거나 같으면 true, 아니면 false

__크거나 같다(<=)__
- 첫 번째 피연산자가 두 번째 피연산자보다 크거나 같으면 true, 아니면 false

- 비교 연산자는 피연산자 타입에 제한이 없다. (하지만 오직 숫자와 문자열만 비교할 수 있기 때문에, 다른 형의 피연산자는 먼저 형변환이 일어난다.)
  - 피연산자 중 어느 하나가 객체로 평가되면, 해당 객체가 원시 값으로 변환되는데, 이 과정에서 valueOf() 메소드의 반환값이 원시타입이면 그 값을 이용하고, 그렇지 않은 경우네는 toString() 메소드의 반환값을 사용한다.
  - 객체가 원시 타입으로 반환되고, 피 연산자가 모두 문자열이면, 알파벳 순서대로 두 문자열을 비교한다.
- ASCII 대문자는 모든 ASCII 소문자보다 작다.
```js
'Zoo' < 'aardvark' // true
```
- 로케일 차이에서 오는 알파벳 순서 차이 등의 문제를 고려하려면, String.localeCompare() 메소드를 사용한다.
- 대소문자를 구분하지 않고 문자를 비교하려면, 두 문자열을 String.toLowerCase() 나 String.toUpperCase() 로 모든 문자열을 대문자나 소문자로 변환한다.
- + 연산자는 문자열을 우선으로 하고, 비교 연산자는 숫자를 우선으로 한다.
```js
1 + 2; // 3
'1' + '2'; // 12
'1' + 2; // 12
11 < 3 // false
'11' < '3' // false
'11' < 3 // false
'one' < 3 // false : NaN < 3
```
- <= 나 >= 는 동치 연산자의 개념을 가져오지 않고, 크지 않다, 작지 않다 로 정의된다.
- 두 피연산자 중 하나가 NaN 이면, 모든 비교연산자는 false 를 반환한다.

### in 연산자
- in 연산자는 좌변의 피연산자로 문자열을 받고, 우변의 피연산자로 객체나 배열을 받는다.
  - 좌변 값이 우변 객체의 프로퍼티 이름일 경우, true 를 반환한다.
```js
var point = { x: 1, y: 1 };
'x' in point; // true
'z' in point; // false
'toString' in point; // true
var data = [7, 8, 9];
'0' in data; // true
1 in data; // true
3 in data; // false
```

### instanceof 연산자
- instanceof 는 좌변의 피연산자로 객체, 우변의 피연산자로 객체 클래스의 이름을 식별자로 받는다.
  - 우변의 피연산자가 함수(클래스) 가 아니면, TypeError 가 발생한다.
- 좌변에 오는 객체가 우변 클래스의 인스턴스이면 true, 아니면 false 이다.
```js
var d = new Date();
d instanceof Date; // true
d instanceof Object; // true : 모든 객체는 Object 의 인스턴스이다.
d instanceof Number; // false
var a = [1, 2, 3];
a instanceof Array; // true
a instanceof Object; // true
a instanceof RegExp; // false
```
- 모든 객체는 Object 의 인스턴스이다.
- instanceof 객체가 클래스 객체의 인스턴스인지 판단할 때, 해당 객체의 '상위 클래스' 들도 고려한다.
- instanceof 연산자가 어떻게 동작하는지 이해하기 위해서는 프로토타입 체인을 먼저 이해해야 한다.
  - o instanceof f 를 평가하기 위해, f.prototype 을 평가한 후, o 의 프로토타입 체인에 그 값이 나타나는지를 검색한다.

